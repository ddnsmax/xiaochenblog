---
title: æ— é™å®¹é‡ç½‘ç›˜ä»£ç 
description: é€šè¿‡åˆ†ç‰‡10Mä¸Šä¼ åˆ°TG
publishDate: 2025-08-19
tags:
  - ä»£ç 
ogImage: /https://cloud.chenyong.eu.org/file/97H4LJRa.png
---
```
const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const { pathname } = url;

    // ---- Basic env checks ----
    const botToken = env.BOT_TOKEN;
    const chatId = env.CHAT_ID;
    if (!botToken || !chatId || !env.UPLOAD_STORE) {
      return new Response('Server not configured (missing BOT_TOKEN / CHAT_ID / UPLOAD_STORE).', { status: 500 });
    }

    // ======== ROUTES ========

    // å‰å°ä¸Šä¼ é¡µ
    if (request.method === 'GET' && pathname === '/') {
      return noStoreHTML(getUploadFormWithProgress());
    }

    // å…¼å®¹æ—§è·¯å¾„ï¼š/files -> /admin
    if (request.method === 'GET' && pathname === '/files') {
      return Response.redirect(`${url.origin}/admin`, 302);
    }

    // åå°é¡µé¢ï¼ˆBasic Authï¼‰ â€”â€”ã€æ ‡é¢˜ä¸€è‡´ã€‘
    if (request.method === 'GET' && pathname === '/admin') {
      const auth = await requireAdmin(request, env);
      if (auth instanceof Response) return auth;
      return noStoreHTML(getAdminPage()); // ç¦æ­¢ç¼“å­˜
    }

    // åå°ï¼šæ–‡ä»¶åˆ—è¡¨ JSONï¼ˆBasic Authï¼‰
    if (request.method === 'GET' && pathname === '/api/files') {
      const auth = await requireAdmin(request, env);
      if (auth instanceof Response) return auth;

      const sortBy = url.searchParams.get('sort') || 'date';
      const order = url.searchParams.get('order') || 'desc';
      const files = await listFiles(env.UPLOAD_STORE, sortBy, order);

      return noStoreJSON({ files });
    }

    // åˆå§‹åŒ–ä¸Šä¼ 
    if (request.method === 'POST' && pathname === '/upload/init') {
      let payload;
      try { payload = await request.json(); } catch { payload = {}; }
      const { fileName, size, mime } = payload || {};
      if (!fileName || typeof size !== 'number') {
        return json({ error: 'bad init payload' }, 400);
      }
      const uploadId = crypto.randomUUID();
      const manifest = {
        uploadId, fileName, mime, size,
        parts: [], createdAt: new Date().toISOString(), finished: false
      };
      await env.UPLOAD_STORE.put(`upload:${uploadId}`, JSON.stringify(manifest));
      return json({ uploadId, chunkSize: CHUNK_SIZE });
    }

    // ä¸Šä¼ åˆ†ç‰‡/æ•´æ–‡ä»¶ï¼ˆå‰ç«¯å¯èƒ½æ ¹æ®è§„åˆ™åªå‘ 1 ç‰‡ï¼‰
    if (request.method === 'POST' && pathname === '/upload/chunk') {
      const form = await request.formData();
      const uploadId = form.get('uploadId');
      const index = Number(form.get('index'));
      const total = Number(form.get('total'));
      const chunk = form.get('chunk');
      const fName = form.get('fileName') || 'file';

      if (!uploadId || Number.isNaN(index) || Number.isNaN(total) || !chunk) {
        return json({ error: 'bad chunk payload' }, 400);
      }

      // å‘é€åˆ° Telegram
      const caption = `${fName} [part ${index + 1}/${total}] (${uploadId})`;
      const tgResp = await postReq('sendDocument', [
        { chat_id: env.CHAT_ID },
        { document: chunk },
        { caption },
        { disable_notification: 'true' }
      ], botToken);
      const tgJson = await tgResp.json().catch(() => ({}));
      if (!tgResp.ok || !tgJson.ok) {
        return json({ error: 'telegram failed', detail: tgJson?.description || '' }, 502);
      }

      // â€”â€” å…³é”®ä¿®å¤ï¼šåªå–â€œåŸå§‹æ–‡ä»¶â€çš„ file_idï¼Œé¿å…è¯¯å–åˆ°ç¼©ç•¥å›¾ç­‰å¯¼è‡´åˆå¹¶é”™è¯¯/ä¸‹è½½ä¸å®Œæ•´
      const msg = tgJson.result || {};
      let fileIdCandidate =
        msg.document?.file_id ||
        msg.video?.file_id ||
        msg.audio?.file_id ||
        msg.animation?.file_id ||
        (Array.isArray(msg.photo) && msg.photo.length ? msg.photo[msg.photo.length - 1].file_id : null);

      if (!fileIdCandidate) {
        // å…œåº•ï¼ˆéå¸¸å°‘è§ï¼‰ï¼šä»é€’å½’éå†ä¸­å–æœ€åä¸€ä¸ª file_id
        const all = extractFileIds(tgJson);
        fileIdCandidate = all[all.length - 1];
      }
      if (!fileIdCandidate) {
        return json({ error: 'no file_id found in telegram response' }, 502);
      }

      // å†å– file_path
      const fileResp = await postReq('getFile', [{ file_id: fileIdCandidate }], botToken);
      const fileJson = await fileResp.json().catch(() => ({}));
      if (!fileResp.ok || !fileJson.ok) {
        return json({ error: 'getFile failed' }, 502);
      }

      // å†™å…¥åˆ†ç‰‡ä¿¡æ¯
      const key = `upload:${uploadId}`;
      const raw = await env.UPLOAD_STORE.get(key);
      if (!raw) return json({ error: 'upload not found' }, 404);
      const manifest = JSON.parse(raw);
      if (manifest.finished) return json({ error: 'already finished' }, 409);

      const partRecord = {
        index,
        file_id: fileIdCandidate,
        file_path: fileJson.result.file_path,
        size: chunk.size // è®°å½•çœŸå®ç‰‡å¤§å°ï¼Œåç»­ç”¨äº Range æ˜ å°„
      };
      const existingIdx = manifest.parts.findIndex(p => p.index === index);
      if (existingIdx >= 0) manifest.parts[existingIdx] = partRecord;
      else manifest.parts.push(partRecord);

      await env.UPLOAD_STORE.put(key, JSON.stringify(manifest));
      return json({ ok: true });
    }

    // å®Œæˆä¸Šä¼ ï¼ˆç™»è®° file: è®°å½•ï¼‰
    if (request.method === 'POST' && pathname === '/upload/complete') {
      let payload;
      try { payload = await request.json(); } catch { payload = {}; }
      const { uploadId, total } = payload || {};
      const key = `upload:${uploadId}`;
      const raw = await env.UPLOAD_STORE.get(key);
      if (!raw) return json({ error: 'upload not found' }, 404);

      const manifest = JSON.parse(raw);
      if (manifest.parts.length !== total) {
        return json({ error: 'parts mismatch', have: manifest.parts.length, expect: total }, 409);
      }
      manifest.parts.sort((a, b) => a.index - b.index);
      manifest.finished = true;
      await env.UPLOAD_STORE.put(key, JSON.stringify(manifest));

      const recordKey = `file:${uploadId}`;
      const totalSize = calcTotalSize(manifest);
      const display = {
        key: recordKey,
        uploadId,
        title: manifest.fileName,
        fileName: manifest.fileName,
        fileType: getFileType(manifest.fileName || ''),
        size: totalSize,
        downloadUrl: `${url.origin}/download/${uploadId}`,
        previewUrl: `${url.origin}/preview/${uploadId}`,
        uploadDate: new Date().toISOString(),
        chunked: manifest.parts.length > 1,
        parts: manifest.parts.length,
        mime: manifest.mime || 'application/octet-stream'
      };
      await env.UPLOAD_STORE.put(recordKey, JSON.stringify(display));

      return json({ ok: true, downloadUrl: display.downloadUrl, previewUrl: display.previewUrl });
    }

    // ä¸‹è½½ï¼ˆattachmentï¼‰â€”â€”ã€å®Œæ•´ä¸‹è½½ + ä¿ç•™åŸæ–‡ä»¶åï¼›æ”¯æŒ Range/æ–­ç‚¹ã€‘
    if (request.method === 'GET' && pathname.startsWith('/download/')) {
      const uploadId = pathname.split('/')[2];
      return mergeAndRespond(uploadId, env, botToken, 'attachment', request);
    }

    // é¢„è§ˆï¼ˆinlineï¼Œæ”¯æŒè§†é¢‘æ’­æ”¾å™¨ Range æ’­æ”¾ï¼‰
    if (request.method === 'GET' && pathname.startsWith('/preview/')) {
      const uploadId = pathname.split('/')[2];
      return mergeAndRespond(uploadId, env, botToken, 'inline', request);
    }

    // åˆ é™¤ï¼ˆBasic Authï¼‰
    if (request.method === 'DELETE' && pathname.startsWith('/delete/')) {
      const auth = await requireAdmin(request, env);
      if (auth instanceof Response) return auth;

      const key = decodeURIComponent(pathname.slice('/delete/'.length));
      await env.UPLOAD_STORE.delete(key);
      if (key.startsWith('file:')) {
        const uploadId = key.slice('file:'.length);
        await env.UPLOAD_STORE.delete(`upload:${uploadId}`);
      }
      return noStoreJSON({ success: true });
    }

    return new Response('Not Found', { status: 404 });
  }
};

// ============= Helpers =============

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: { 'Content-Type': 'application/json; charset=utf-8' }
  });
}

// ç¦æ­¢ç¼“å­˜ï¼ˆJSONï¼‰
function noStoreJSON(obj, status = 200) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      'Cache-Control': 'no-store, no-cache, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    }
  });
}

// ç¦æ­¢ç¼“å­˜ï¼ˆHTMLï¼‰
function noStoreHTML(html, status = 200) {
  return new Response(html, {
    status,
    headers: {
      'Content-Type': 'text/html; charset=utf-8',
      'Cache-Control': 'no-store, no-cache, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    }
  });
}

// Basic Auth æ ¡éªŒï¼šè®¾ç½®äº† ADMIN_USER/ADMIN_PASS æ‰å¯ç”¨ï¼›æœªè®¾ç½®åˆ™æ”¾è¡Œ
async function requireAdmin(request, env) {
  if (!env.ADMIN_USER || !env.ADMIN_PASS) return true;

  const hdr = request.headers.get('Authorization') || '';
  const need = new Response('Unauthorized', {
    status: 401,
    headers: { 'WWW-Authenticate': 'Basic realm="Admin", charset="UTF-8"' }
  });

  if (!hdr.startsWith('Basic ')) return need;
  try {
    const decoded = atob(hdr.slice(6));
    const idx = decoded.indexOf(':');
    if (idx < 0) return need;
    const user = decoded.slice(0, idx);
    const pass = decoded.slice(idx + 1);
    if (user === env.ADMIN_USER && pass === env.ADMIN_PASS) return true;
    return need;
  } catch {
    return need;
  }
}

function getFileType(fileName) {
  const ext = (fileName.split('.').pop() || '').toLowerCase();
  const map = {
    pdf: 'PDF Document',
    doc: 'Word Document',
    docx: 'Word Document',
    xls: 'Excel Spreadsheet',
    xlsx: 'Excel Spreadsheet',
    jpg: 'Image', jpeg: 'Image', png: 'Image', gif: 'Image', webp: 'Image',
    zip: 'Archive', rar: 'Archive', '7z': 'Archive',
    txt: 'Text File', md: 'Text File',
    mp4: 'Video', webm: 'Video', mov: 'Video',
    mp3: 'Audio', wav: 'Audio', m4a: 'Audio'
  };
  return map[ext] || 'Other';
}

async function listFiles(kv, sortBy = 'date', order = 'desc') {
  const list = await kv.list();
  const files = [];
  for (const key of list.keys) {
    if (!key.name.startsWith('file:')) continue;
    const value = await kv.get(key.name);
    if (value) files.push({ ...JSON.parse(value), key: key.name });
  }
  files.sort((a, b) => {
    switch (sortBy) {
      case 'name': return order === 'asc' ? a.title.localeCompare(b.title) : b.title.localeCompare(a.title);
      case 'type': return order === 'asc' ? a.fileType.localeCompare(b.fileType) : b.fileType.localeCompare(a.fileType);
      case 'size': return order === 'asc' ? (a.size - b.size) : (b.size - a.size);
      case 'date':
      default:
        return order === 'asc'
          ? new Date(a.uploadDate) - new Date(b.uploadDate)
          : new Date(b.uploadDate) - new Date(a.uploadDate);
    }
  });
  return files;
}

async function postReq(url, fields, botToken) {
  const formData = new FormData();
  fields.forEach(obj => { for (let k in obj) formData.append(k, obj[k]); });
  return fetch(`https://api.telegram.org/bot${botToken}/${url}`, { method: 'POST', body: formData });
}

function extractFileIds(obj) {
  const out = [];
  (function dfs(x) {
    if (x && typeof x === 'object') {
      if (x.file_id) out.push(x.file_id);
      Object.values(x).forEach(dfs);
    }
  })(obj);
  return [...new Set(out)];
}

// === æ ¸å¿ƒï¼šåˆå¹¶å¹¶å“åº”ï¼Œæ”¯æŒ Rangeï¼ˆåœ¨çº¿æ’­æ”¾/æ–­ç‚¹ä¸‹è½½ï¼‰ ===
async function mergeAndRespond(uploadId, env, botToken, disposition, request) {
  const manRaw = await env.UPLOAD_STORE.get(`upload:${uploadId}`);
  if (!manRaw) return new Response('Not Found', { status: 404 });

  const manifest = JSON.parse(manRaw);
  if (!manifest.finished || !manifest.parts?.length) {
    return new Response('File not ready', { status: 409 });
  }
  manifest.parts.sort((a, b) => a.index - b.index);

  const totalSize = calcTotalSize(manifest);
  const filename = manifest.fileName || `file-${uploadId}`;
  const encoded = encodeRFC5987ValueChars(filename);
  const mime = manifest.mime || 'application/octet-stream';

  // è§£æ Range
  const rangeHeader = request.headers.get('Range');
  let start = 0, end = totalSize ? totalSize - 1 : undefined;
  let status = 200;

  if (rangeHeader && totalSize) {
    const m = /^bytes=(\d*)-(\d*)$/.exec(rangeHeader);
    if (m) {
      const s = m[1] ? parseInt(m[1], 10) : 0;
      const e = m[2] ? parseInt(m[2], 10) : (totalSize - 1);
      if (Number.isFinite(s) && Number.isFinite(e) && s <= e && e < totalSize) {
        start = s; end = e; status = 206;
      }
    }
  }

  const stream = new ReadableStream({
    async start(controller) {
      try {
        await pipeRangeFromParts(controller, manifest.parts, botToken, start, end);
        controller.close();
      } catch (e) {
        controller.error(e);
      }
    }
  });

  const headers = new Headers({
    'Content-Type': mime,
    'Accept-Ranges': 'bytes',
    'Content-Disposition': `${disposition}; filename="${sanitizeFilename(filename)}"; filename*=UTF-8''${encoded}`,
    'Cache-Control': disposition === 'inline' ? 'public, max-age=3600, immutable' : 'no-store'
  });

  if (typeof totalSize === 'number') {
    if (status === 206) {
      headers.set('Content-Range', `bytes ${start}-${end}/${totalSize}`);
      headers.set('Content-Length', String(end - start + 1));
    } else {
      headers.set('Content-Length', String(totalSize));
    }
  }

  return new Response(stream, { status, headers });
}

// å°†æŒ‡å®šåŒºé—´ [start, end] ä»å¤šä¸ªåˆ†ç‰‡é¡ºåºå†™å…¥ controller
async function pipeRangeFromParts(controller, parts, botToken, start, end) {
  let offset = 0;
  const ranges = parts.map(p => {
    const size = Number(p.size) || 0;
    const r = { part: p, start: offset, end: offset + size - 1, size };
    offset += size;
    return r;
  });

  for (const r of ranges) {
    if (r.size <= 0) continue;
    if (r.end < start) continue;
    if (r.start > end) break;

    const localStart = Math.max(0, start - r.start);
    const localEnd = Math.min(r.size - 1, end - r.start);
    const needBytes = localEnd - localStart + 1;
    if (needBytes <= 0) continue;

    const tgUrl = `https://api.telegram.org/file/bot${botToken}/${r.part.file_path}`;

    // â€”â€” ä¼˜å…ˆå°è¯• Range è¯·æ±‚ä¸Šæ¸¸ï¼Œè‹¥ä¸æ”¯æŒåˆ™å›é€€åˆ° 200 å…¨é‡å†æœ¬åœ°è·³è¿‡
    const tryRange = localStart > 0 || localEnd < r.size - 1;
    const rangeHeaders = tryRange ? { 'Range': `bytes=${localStart}-${localEnd}` } : undefined;
    let resp = await fetch(tgUrl, { headers: rangeHeaders });
    if (!resp.ok || !resp.body) {
      // å›é€€ä¸€æ¬¡ï¼ˆæ—  Rangeï¼‰
      resp = await fetch(tgUrl);
      if (!resp.ok || !resp.body) throw new Error('fetch part failed');
    }

    const reader = resp.body.getReader();
    let toSkip = resp.status === 206 ? 0 : localStart; // è‹¥ä¸Šæ¸¸å·² Rangeï¼Œå°±ä¸éœ€è¦æœ¬åœ°è·³è¿‡
    let sent = 0;

    // è·³è¿‡å‰ç¼€ï¼ˆå½“ä¸Šæ¸¸ 200 æœª Range æ—¶ï¼‰
    while (toSkip > 0) {
      const { value, done } = await reader.read();
      if (done) break;
      if (value.byteLength <= toSkip) {
        toSkip -= value.byteLength;
        continue;
      } else {
        const slice = value.slice(toSkip);
        const toSend = Math.min(slice.byteLength, needBytes - sent);
        if (toSend > 0) controller.enqueue(slice.slice(0, toSend));
        sent += toSend;
        toSkip = 0;
        if (sent >= needBytes) {
          // è¯»å¤Ÿäº†ï¼Œå–æ¶ˆä¸Šæ¸¸è¯»å–ï¼Œé‡Šæ”¾è¿æ¥
          try { await reader.cancel(); } catch {}
          break;
        }
      }
    }

    // æ­£å¸¸å‘é€é˜¶æ®µ
    while (sent < needBytes) {
      const { value, done } = await reader.read();
      if (done) break;
      const toSend = Math.min(value.byteLength, needBytes - sent);
      if (toSend > 0) controller.enqueue(value.slice(0, toSend));
      sent += toSend;

      if (toSend < value.byteLength || sent >= needBytes) {
        // å·²å¤Ÿï¼Œå–æ¶ˆå‰©ä½™
        try { await reader.cancel(); } catch {}
        break;
      }
    }
  }
}

function calcTotalSize(manifest) {
  if (manifest?.parts?.length) {
    const s = manifest.parts.reduce((n, p) => n + (Number(p.size) || 0), 0);
    return s || Number(manifest.size) || undefined;
  }
  return Number(manifest.size) || undefined;
}

function sanitizeFilename(name) {
  // ä¿ç•™åŸåç”¨äº filenameï¼ˆå°½é‡ä¸è½¬ä¹‰ï¼‰ï¼Œä»…å»é™¤æ¢è¡Œä¸å¼•å·
  return String(name).replace(/[\r\n"]/g, '_');
}
function encodeRFC5987ValueChars(str) {
  return encodeURIComponent(str)
    .replace(/['()*]/g, c => '%' + c.charCodeAt(0).toString(16))
    .replace(/%(7C|60|5E)/g, (m, hex) => '%' + hex.toLowerCase());
}

// ============= Frontend (HTML) =============

// å‰å°ä¸Šä¼ é¡µï¼ˆå¤šæ–‡ä»¶ + å¹¶å‘ + æ™ºèƒ½åˆ†ç‰‡ï¼›æ ‡é¢˜ä¸ç«™åä¸€è‡´ï¼‰
function getUploadFormWithProgress() {
  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>æ— é™åˆ¶å®¹é‡ç½‘ç›˜-æ›´å¤šé¡¹ç›®ï¼šwww.l42.cn</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  .upload-area { border: 2px dashed #4F46E5; }
  .upload-area.dragging { background: rgba(79,70,229,0.1); }
  .icon-btn { display:inline-flex; align-items:center; gap:.5rem; }
  .ext-link { text-decoration: underline dotted; }
  .file-row { border:1px solid rgba(255,255,255,.08); }
</style>
</head>
<body class="bg-gray-900 min-h-screen">
  <div class="container mx-auto px-4 py-8">
    <div class="max-w-3xl mx-auto bg-gray-800 rounded-lg shadow-xl p-8">
      <div class="flex items-center justify-between mb-6">
        <h1 class="text-2xl font-bold text-white">æ— é™åˆ¶å®¹é‡ç½‘ç›˜-æ›´å¤šé¡¹ç›®ï¼šwww.l42.cn</h1>
        <div class="flex items-center gap-3">
          <a class="icon-btn text-gray-200 hover:text-white" href="https://github.com/ddnsmax/Unlimited-cloud-storage" target="_blank" rel="noopener">
            ${svgGithub()} <span class="hidden sm:inline ext-link">GitHub</span>
          </a>
          <a class="icon-btn text-gray-200 hover:text-white" href="https://www.l42.cn" target="_blank" rel="noopener">
            ${svgLink()} <span class="hidden sm:inline ext-link">å¼€å‘è€…åšå®¢</span>
          </a>
        </div>
      </div>

      <form class="space-y-6" id="uploadForm">
        <div class="upload-area rounded-lg p-8 text-center cursor-pointer" id="dropZone">
          <div class="space-y-4">
            <span class="text-4xl">ğŸ“</span>
            <p class="text-white text-lg">æ‹–æ‹½æ–‡ä»¶åˆ°è¿™é‡Œï¼Œæˆ–ç‚¹å‡»é€‰æ‹©ï¼ˆå¯å¤šé€‰ï¼‰</p>
            <p class="text-gray-400 text-sm">æ™ºèƒ½åˆ†ç‰‡ï¼šè§†é¢‘â‰¤50MBã€å›¾ç‰‡â‰¤10MBä¸åˆ†ç‰‡ï¼›å…¶ä½™/è¶…é™æŒ‰10MBåˆ†ç‰‡</p>
          </div>
          <input type="file" name="file" id="fileInput" multiple class="hidden">
        </div>

        <div id="filesList" class="space-y-3"></div>

        <div class="flex flex-wrap justify-between gap-3">
          <button type="submit" id="uploadBtn" class="bg-indigo-600 text-white px-6 py-2 rounded hover:bg-indigo-700 transition disabled:opacity-50" disabled>
            å¼€å§‹ä¸Šä¼ 
          </button>
          <a href="/admin" class="bg-gray-600 text-white px-6 py-2 rounded hover:bg-gray-700 transition">åå°ç®¡ç†</a>
        </div>

        <div id="copyLinkSection" class="hidden mt-4">
          <p class="text-white mb-2">ä¸Šä¼ å®Œæˆçš„æ–‡ä»¶é“¾æ¥ï¼š</p>
          <div id="linksWrap" class="grid gap-3"></div>
        </div>
      </form>
    </div>
  </div>

<script>
const CHUNK_SIZE = ${CHUNK_SIZE};
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const filesList = document.getElementById('filesList');
const uploadBtn = document.getElementById('uploadBtn');
const uploadForm = document.getElementById('uploadForm');
const copyLinkSection = document.getElementById('copyLinkSection');
const linksWrap = document.getElementById('linksWrap');

let selected = []; // {file, id, status, rowEl, progressEl, speedEl, done:false}

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragging'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragging'));
dropZone.addEventListener('drop', (e) => {
  e.preventDefault(); dropZone.classList.remove('dragging');
  if (e.dataTransfer.files.length) {
    addFiles([...e.dataTransfer.files]);
  }
});
fileInput.addEventListener('change', (e) => { if (e.target.files.length) addFiles([...e.target.files]); });

function addFiles(files){
  // ä¸æ¸…ç©ºåŸæœ‰æ–‡ä»¶ï¼Œå…è®¸è¿½åŠ 
  for(const f of files){
    const id = crypto.randomUUID();
    const row = document.createElement('div');
    row.className = 'file-row bg-gray-700 p-4 rounded-lg';
    row.innerHTML = \`
      <div class="flex items-center justify-between gap-3">
        <div class="min-w-0">
          <div class="text-white font-medium truncate">\${f.name}</div>
          <div class="text-gray-300 text-xs mt-1">\${formatFileSize(f.size)} Â· \${f.type || 'application/octet-stream'}</div>
        </div>
        <button type="button" class="text-red-300 hover:text-red-200 shrink-0" data-act="remove">ç§»é™¤</button>
      </div>
      <div class="mt-3">
        <div class="w-full bg-gray-600 rounded h-3 overflow-hidden">
          <div class="h-3 bg-indigo-500" style="width:0%"></div>
        </div>
        <div class="flex justify-between text-xs text-gray-300 mt-1">
          <span class="status">å¾…ä¸Šä¼ </span>
          <span class="speed"></span>
        </div>
      </div>\`;
    filesList.appendChild(row);
    const progressEl = row.querySelector('.h-3');
    const statusEl = row.querySelector('.status');
    const speedEl = row.querySelector('.speed');
    row.addEventListener('click',(ev)=>{
      if(ev.target && ev.target.getAttribute('data-act')==='remove'){
        // è‹¥å·²å®Œæˆåˆ™ä»…ä»åˆ—è¡¨ç§»é™¤ï¼›è‹¥æ­£åœ¨ä¸Šä¼ åˆ™ä¸å…è®¸
        const idx = selected.findIndex(x=>x.id===id);
        if(idx>=0 && !selected[idx].uploading){
          selected.splice(idx,1);
          row.remove();
          uploadBtn.disabled = selected.filter(x=>!x.done).length===0;
        }
      }
    });
    selected.push({ file:f, id, rowEl:row, progressEl, statusEl, speedEl, done:false, uploading:false });
  }
  uploadBtn.disabled = selected.filter(x=>!x.done).length===0;
}

function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024, sizes = ['Bytes','KB','MB','GB','TB'];
  const i = Math.floor(Math.log(bytes)/Math.log(k));
  return (bytes/Math.pow(k,i)).toFixed(2) + ' ' + sizes[i];
}

function humanSpeed(bps) {
  const units = ['B/s','KB/s','MB/s','GB/s'];
  let idx = 0;
  while (bps >= 1024 && idx < units.length-1) { bps /= 1024; idx++; }
  return bps.toFixed(1) + ' ' + units[idx];
}

function needChunk(file){
  // è§„åˆ™ï¼šè§†é¢‘â‰¤50MBä¸åˆ†ç‰‡ï¼›å›¾ç‰‡â‰¤10MBä¸åˆ†ç‰‡ï¼›å…¶ä½™/è¶…é™æŒ‰10MBåˆ†ç‰‡
  const isVideo = (file.type||'').startsWith('video/');
  const isImage = (file.type||'').startsWith('image/');
  if (isVideo) return file.size > 50*1024*1024;
  if (isImage) return file.size > 10*1024*1024;
  return true; // å…¶ä»–ç±»å‹å§‹ç»ˆåˆ†ç‰‡
}

async function uploadOne(entry){
  const file = entry.file;
  entry.uploading = true;
  entry.statusEl.textContent = 'åˆå§‹åŒ–...';
  const initResp = await fetch('/upload/init', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ fileName: file.name, size: file.size, mime: file.type })
  });
  const initData = await initResp.json().catch(()=> ({}));
  if (!initResp.ok || !initData.uploadId) throw new Error('åˆå§‹åŒ–å¤±è´¥');
  const uploadId = initData.uploadId;
  const chunking = needChunk(file);
  const chunkSize = chunking ? (initData.chunkSize || CHUNK_SIZE) : file.size; // ä¸åˆ†ç‰‡ï¼šæ•´ä¸ªæ–‡ä»¶ä¸€æ¬¡å‘é€
  const total = Math.ceil(file.size / chunkSize);

  let uploadedBytes = 0;
  let lastTime = Date.now();
  let lastUploaded = 0;

  for (let i = 0; i < total; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const blob = file.slice(start, end);

    await new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', '/upload/chunk');
      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          uploadedBytes += blob.size;
          resolve();
        } else reject(new Error('åˆ†ç‰‡ä¸Šä¼ å¤±è´¥'));
      };
      xhr.onerror = () => reject(new Error('ç½‘ç»œé”™è¯¯'));

      xhr.upload.onprogress = (ev) => {
        const currentSent = ev.lengthComputable ? ev.loaded : 0;
        const overall = Math.min((uploadedBytes + currentSent) / file.size * 100, 100);
        entry.progressEl.style.width = overall.toFixed(2) + '%';
        entry.statusEl.textContent = \`\${overall.toFixed(2)}%\`;

        const now = Date.now();
        if (now - lastTime >= 500) {
          const bytesSince = (uploadedBytes + currentSent) - lastUploaded;
          const bps = bytesSince / ((now - lastTime)/1000);
          entry.speedEl.textContent = humanSpeed(bps);
          lastTime = now; lastUploaded = uploadedBytes + currentSent;
        }
      };

      const form = new FormData();
      form.append('uploadId', uploadId);
      form.append('index', String(i));
      form.append('total', String(total));
      form.append('fileName', file.name);
      // å³ä¾¿ä¸åˆ†ç‰‡ï¼Œè¿™é‡Œä¹Ÿå‘ 1 ç‰‡ï¼ˆæ•´æ–‡ä»¶ï¼‰
      form.append('chunk', blob, chunking ? \`\${file.name}.part\${i}\` : file.name);
      xhr.send(form);
    });
  }

  entry.statusEl.textContent = 'åˆå¹¶ç™»è®°...';
  const completeResp = await fetch('/upload/complete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ uploadId, total })
  });
  const completeData = await completeResp.json().catch(()=> ({}));
  if (!completeResp.ok || !completeData.downloadUrl) throw new Error('å®Œæˆå¤±è´¥');

  // å±•ç¤ºé“¾æ¥ï¼Œä¸æ¸…ç©ºåŸæ–‡ä»¶
  const item = document.createElement('div');
  item.className = 'grid gap-1';
  item.innerHTML = \`
    <div class="text-gray-200 text-sm">æ–‡ä»¶ï¼š<span class="font-medium">\${file.name}</span></div>
    <div class="flex items-center gap-2">
      <input type="text" value="\${completeData.downloadUrl}" readonly class="flex-1 bg-gray-700 text-white p-2 rounded">
      <button type="button" class="copyBtn bg-indigo-600 text-white px-3 py-2 rounded hover:bg-indigo-700" data-val="\${completeData.downloadUrl}">å¤åˆ¶ä¸‹è½½</button>
    </div>
    <div class="flex items-center gap-2">
      <input type="text" value="\${completeData.previewUrl}" readonly class="flex-1 bg-gray-700 text-white p-2 rounded">
      <button type="button" class="copyBtn bg-indigo-600 text-white px-3 py-2 rounded hover:bg-indigo-700" data-val="\${completeData.previewUrl}">å¤åˆ¶é¢„è§ˆ</button>
    </div>\`;
  linksWrap.appendChild(item);
  copyLinkSection.classList.remove('hidden');
  item.querySelectorAll('.copyBtn').forEach(b=>b.addEventListener('click',()=>navigator.clipboard.writeText(b.getAttribute('data-val')).then(()=>alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'))));

  entry.done = true;
  entry.uploading = false;
  entry.statusEl.textContent = 'å®Œæˆ';
  entry.speedEl.textContent = '';
}

function limitConcurrency(tasks, limit=3){
  // ç®€æ˜“å¹¶å‘æ§åˆ¶ï¼Œé¿å…åŒæ—¶è¿‡å¤šè¿æ¥
  let i=0, running=0;
  return new Promise((resolve,reject)=>{
    const results = [];
    const next = ()=>{
      if(i>=tasks.length && running===0) return resolve(results);
      while(running<limit && i<tasks.length){
        const cur = i++;
        running++;
        tasks[cur]().then(r=>{ results[cur]=r; running--; next(); }).catch(e=>{ running--; console.error(e); next(); });
      }
    };
    next();
  });
}

uploadForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  // é˜²æ­¢é‡å¤ç‚¹å‡»æäº¤å¯¼è‡´é‡å¤ä¸Šä¼ 
  if (uploadBtn.dataset.running === '1') return;
  const pending = selected.filter(x=>!x.done && !x.uploading);
  if (!pending.length) return;
  uploadBtn.dataset.running = '1';
  uploadBtn.disabled = true;

  const tasks = pending.map(entry => async ()=> {
    try { await uploadOne(entry); } catch(e){ entry.statusEl.textContent = 'å¤±è´¥'; entry.uploading=false; console.error(e); }
  });

  await limitConcurrency(tasks, 3);

  // å…è®¸å†æ¬¡æ‰‹åŠ¨ç‚¹å‡»é‡æ–°ä¸Šä¼ æœªå®Œæˆ/å¤±è´¥çš„æ¡ç›®ï¼›ä¸è‡ªåŠ¨æ¸…ç©ºå·²é€‰æ–‡ä»¶
  uploadBtn.dataset.running = '0';
  uploadBtn.disabled = selected.filter(x=>!x.done).length===0;
});

// å·¥å…·
document.addEventListener('click',(e)=>{
  const tgt = e.target.closest('[data-target]');
  if(!tgt) return;
  const id = tgt.getAttribute('data-target');
  const val = document.getElementById(id)?.value;
  if(val) navigator.clipboard.writeText(val).then(()=>alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿'));
});
</script>
</body>
</html>`;
}

// åå°ç®¡ç†é¡µï¼ˆå°ºå¯¸ç»Ÿä¸€ï¼›æ ‡é¢˜ä¸æ¨¡å—å·¦è¾¹å¯¹é½åœ¨ä¸€æ¡çº¿ä¸Šï¼‰
function getAdminPage() {
  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ— é™åˆ¶å®¹é‡ç½‘ç›˜-æ›´å¤šé¡¹ç›®ï¼šwww.l42.cn</title>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
<style>
  .upload-area { border: 2px dashed #4F46E5; }
  .upload-area.dragging { background: rgba(79,70,229,0.1); }
  .card { max-width: 64rem; } /* ç»Ÿä¸€æ¨¡å—æœ€å¤§å®½åº¦ */
  /* â€”â€” æ–°å¢ï¼šè®©æ ‡é¢˜å®¹å™¨ä¸å¡ç‰‡åŒå®½ï¼Œå¹¶è¡¥é½ä¸å¡ç‰‡ç›¸åŒçš„æ°´å¹³å†…è¾¹è·ï¼Œå®ç°å·¦ä¾§å®Œå…¨å¯¹é½ */
  .title-wrap { max-width: 64rem; margin: 0 auto; padding-left: 1.5rem; padding-right: 1.5rem; }
</style>
</head>
<body class="bg-gray-900 min-h-screen">
  <div class="container mx-auto px-4 py-8">
    <div class="title-wrap flex items-center justify-between mb-6">
      <h1 class="text-2xl font-bold text-white">æ— é™åˆ¶å®¹é‡ç½‘ç›˜-æ›´å¤šé¡¹ç›®ï¼šwww.l42.cn</h1>
      <a class="inline-flex items-center gap-2 text-gray-200 hover:text-white" href="/" title="å‰å°ä¸Šä¼ ">å‰å°ä¸Šä¼ </a>
    </div>

    <!-- ç®¡ç†ä¸Šä¼ ï¼ˆæ”¯æŒå¤šé€‰å¹¶å‘ï¼›å°ºå¯¸ç»Ÿä¸€ï¼‰ -->
    <div class="card bg-gray-800 rounded-lg shadow p-6 mb-8 mx-auto">
      <h2 class="text-white font-semibold mb-4">ä¸Šä¼ æ–‡ä»¶ï¼ˆå¯å¤šé€‰ï¼‰</h2>
      <form class="space-y-4" id="uploadForm">
        <div class="upload-area rounded-lg p-6 text-center cursor-pointer" id="dropZone">
          <div class="space-y-2">
            <span class="text-3xl">ğŸ“</span>
            <p class="text-white">æ‹–æ‹½æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶ï¼ˆå¯å¤šé€‰ï¼Œæ™ºèƒ½åˆ†ç‰‡ï¼‰</p>
            <p class="text-gray-400 text-xs">è§†é¢‘â‰¤50MBã€å›¾ç‰‡â‰¤10MBä¸åˆ†ç‰‡ï¼›å…¶ä½™/è¶…é™æŒ‰10MBåˆ†ç‰‡</p>
          </div>
          <input type="file" id="fileInput" multiple class="hidden">
        </div>

        <div id="filesList" class="space-y-3"></div>

        <div class="flex gap-3">
          <button type="submit" id="uploadBtn" class="bg-indigo-600 text-white px-5 py-2 rounded hover:bg-indigo-700 disabled:opacity-50" disabled>å¼€å§‹ä¸Šä¼ </button>
          <button type="button" id="refreshBtn" class="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-600">åˆ·æ–°åˆ—è¡¨</button>
        </div>
        <div id="links" class="hidden text-sm text-gray-300 mt-3"></div>
      </form>
    </div>

    <!-- æ’åºï¼ˆå°ºå¯¸ç»Ÿä¸€ï¼‰ -->
    <div class="card bg-gray-800 rounded-lg shadow p-6 mb-4 mx-auto">
      <div class="flex flex-wrap gap-4 items-center">
        <div class="text-white font-semibold">æ–‡ä»¶åˆ—è¡¨</div>
        <div class="text-sm text-gray-300">æ’åºï¼š
          <select id="sortBy" class="bg-gray-700 text-white rounded px-2 py-1">
            <option value="date">æ—¥æœŸ</option>
            <option value="name">åç§°</option>
            <option value="type">ç±»å‹</option>
            <option value="size">å¤§å°</option>
          </select>
          <select id="order" class="bg-gray-700 text-white rounded px-2 py-1">
            <option value="desc">â†“</option>
            <option value="asc">â†‘</option>
          </select>
        </div>
      </div>
    </div>

    <div class="card mx-auto">
      <div id="list" class="grid gap-4"></div>
      <div id="empty" class="hidden text-center text-gray-300 py-12">æš‚æ— æ–‡ä»¶</div>
    </div>
  </div>

<script>
const listEl = document.getElementById('list');
const emptyEl = document.getElementById('empty');
const sortByEl = document.getElementById('sortBy');
const orderEl = document.getElementById('order');
const refreshBtn = document.getElementById('refreshBtn');

sortByEl.addEventListener('change', load);
orderEl.addEventListener('change', load);
refreshBtn.addEventListener('click', load);

async function load(){
  listEl.innerHTML = '';
  const sort = sortByEl.value;
  const order = orderEl.value;
  const noCache = 't=' + Date.now(); // å¼ºåˆ¶é¿å¼€ç¼“å­˜
  const resp = await fetch(\`/api/files?sort=\${sort}&order=\${order}&\${noCache}\`, { cache: 'no-store' });
  const data = await resp.json().catch(()=>({files:[]}));
  const files = data.files || [];
  if(!files.length){ emptyEl.classList.remove('hidden'); return; }
  emptyEl.classList.add('hidden');
  listEl.innerHTML = files.map(renderItem).join('');
}

function renderItem(f){
  const size = formatFileSize(f.size||0);
  const uploaded = new Date(f.uploadDate).toLocaleString();
  const icon = getIcon(f.fileType);
  const previewUrl = f.previewUrl || ('/preview/'+f.uploadId);
  return \`
    <div class="bg-gray-800 p-5 rounded-lg shadow">
      <div class="flex gap-4">
        <div class="text-4xl">\${icon}</div>
        <div class="flex-1 min-w-0">
          <div class="text-white font-semibold truncate">\${f.title}</div>
          <div class="text-gray-400 text-sm mt-1 space-y-1">
            <div>ç±»å‹ï¼š\${f.fileType}</div>
            <div>å¤§å°ï¼š\${size}</div>
            <div>æ—¶é—´ï¼š\${uploaded}</div>
            <div>åˆ†ç‰‡ï¼š\${f.parts || 1}</div>
          </div>
          <div class="mt-3 flex flex-wrap gap-2">
            <a class="bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700" href="\${previewUrl}" target="_blank" rel="noopener">é¢„è§ˆ</a>
            <a class="bg-gray-700 text-white px-3 py-1 rounded hover:bg-gray-600" href="\${f.downloadUrl}" target="_blank" rel="noopener">ä¸‹è½½</a>
            <button class="bg-green-700 text-white px-3 py-1 rounded hover:bg-green-600" onclick="copy('\${f.downloadUrl}')">å¤åˆ¶ä¸‹è½½é“¾æ¥</button>
            <button class="bg-red-700 text-white px-3 py-1 rounded hover:bg-red-600" onclick="del('\${encodeURIComponent(f.key)}')">åˆ é™¤</button>
          </div>
        </div>
      </div>
    </div>\`;
}

function getIcon(type){
  const map = {
    'PDF Document':'ğŸ“„','Word Document':'ğŸ“','Excel Spreadsheet':'ğŸ“Š','Image':'ğŸ–¼ï¸',
    'Archive':'ğŸ“¦','Text File':'ğŸ“ƒ','Video':'ğŸ¥','Audio':'ğŸµ','Other':'ğŸ“'
  };
  return map[type] || 'ğŸ“';
}

function formatFileSize(bytes){
  if (!bytes) return '0 Bytes';
  const k = 1024; const sizes = ['Bytes','KB','MB','GB','TB'];
  const i = Math.floor(Math.log(bytes)/Math.log(k));
  return (bytes/Math.pow(k,i)).toFixed(2) + ' ' + sizes[i];
}

async function del(key){
  if(!confirm('ç¡®è®¤åˆ é™¤è¯¥æ–‡ä»¶åŠå…¶ä¸Šä¼ è®°å½•ï¼Ÿ')) return;
  await fetch('/delete/'+key, { method:'DELETE', cache:'no-store' });
  await load();
}

function copy(text){ navigator.clipboard.writeText(text).then(()=>alert('å·²å¤åˆ¶')); }

// ========== ç®¡ç†é¡µå¤šæ–‡ä»¶å¹¶å‘ä¸Šä¼ ï¼ˆä¸å‰å°ä¸€è‡´çš„è§„åˆ™ï¼Œä¸æ¸…ç©ºé€‰æ‹©ï¼Œé˜²é‡å¤æäº¤ï¼‰ ==========
const dz = document.getElementById('dropZone');
const fi = document.getElementById('fileInput');
const form = document.getElementById('uploadForm');
const filesList = document.getElementById('filesList');
const ub = document.getElementById('uploadBtn');
const links = document.getElementById('links');

let selected = [];

dz.addEventListener('click', ()=>fi.click());
dz.addEventListener('dragover', e=>{ e.preventDefault(); dz.classList.add('dragging'); });
dz.addEventListener('dragleave', ()=>dz.classList.remove('dragging'));
dz.addEventListener('drop', e=>{
  e.preventDefault(); dz.classList.remove('dragging');
  if(e.dataTransfer.files.length){ addFiles([...e.dataTransfer.files]); }
});
fi.addEventListener('change', ()=>{ if(fi.files.length) addFiles([...fi.files]); });

function addFiles(files){
  for(const f of files){
    const id = crypto.randomUUID();
    const row = document.createElement('div');
    row.className = 'bg-gray-700 p-4 rounded-lg file-row';
    row.innerHTML = \`
      <div class="flex items-center justify-between gap-3">
        <div class="min-w-0">
          <div class="text-white font-medium truncate">\${f.name}</div>
          <div class="text-gray-300 text-xs mt-1">\${formatFileSize(f.size)} Â· \${f.type || 'application/octet-stream'}</div>
        </div>
        <button type="button" class="text-red-300 hover:text-red-200 shrink-0" data-act="remove">ç§»é™¤</button>
      </div>
      <div class="mt-3">
        <div class="w-full bg-gray-600 rounded h-3 overflow-hidden">
          <div class="h-3 bg-indigo-500" style="width:0%"></div>
        </div>
        <div class="flex justify-between text-xs text-gray-300 mt-1">
          <span class="status">å¾…ä¸Šä¼ </span>
          <span class="speed"></span>
        </div>
      </div>\`;
    filesList.appendChild(row);
    const progressEl = row.querySelector('.h-3');
    const statusEl = row.querySelector('.status');
    const speedEl = row.querySelector('.speed');
    row.addEventListener('click',(ev)=>{
      if(ev.target && ev.target.getAttribute('data-act')==='remove'){
        const idx = selected.findIndex(x=>x.id===id);
        if(idx>=0 && !selected[idx].uploading){
          selected.splice(idx,1);
          row.remove();
          ub.disabled = selected.filter(x=>!x.done).length===0;
        }
      }
    });
    selected.push({ file:f, id, rowEl:row, progressEl, statusEl, speedEl, done:false, uploading:false });
  }
  ub.disabled = selected.filter(x=>!x.done).length===0;
}

function needChunk(file){
  const isVideo = (file.type||'').startsWith('video/');
  const isImage = (file.type||'').startsWith('image/');
  if (isVideo) return file.size > 50*1024*1024;
  if (isImage) return file.size > 10*1024*1024;
  return true;
}

async function uploadOne(entry){
  const file = entry.file;
  entry.uploading = true;
  entry.statusEl.textContent = 'åˆå§‹åŒ–...';
  const initResp = await fetch('/upload/init',{ method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ fileName:file.name, size:file.size, mime:file.type })});
  const initData = await initResp.json().catch(()=> ({}));
  if(!initResp.ok || !initData.uploadId) throw new Error('åˆå§‹åŒ–å¤±è´¥');
  const uploadId = initData.uploadId;
  const chunking = needChunk(file);
  const chunkSize = chunking ? (initData.chunkSize || ${CHUNK_SIZE}) : file.size;
  const total = Math.ceil(file.size/chunkSize);

  let uploadedBytes = 0, lastTime=Date.now(), lastUploaded=0;

  for(let i=0;i<total;i++){
    const start=i*chunkSize, end=Math.min(start+chunkSize, file.size);
    const blob=file.slice(start,end);
    await new Promise((resolve,reject)=>{
      const xhr=new XMLHttpRequest();
      xhr.open('POST','/upload/chunk');
      xhr.onload=()=>{ if(xhr.status>=200 && xhr.status<300){ uploadedBytes+=blob.size; resolve(); } else reject(new Error('chunk failed')); }
      xhr.onerror=()=>reject(new Error('network'));
      xhr.upload.onprogress=(ev)=>{
        const current = ev.lengthComputable ? ev.loaded : 0;
        const pct = Math.min((uploadedBytes + current)/file.size*100, 100);
        entry.progressEl.style.width = pct.toFixed(2)+'%'; entry.statusEl.textContent = pct.toFixed(2)+'%';
        const now=Date.now(); if(now-lastTime>=500){ const bps=((uploadedBytes+current)-lastUploaded)/((now-lastTime)/1000); entry.speedEl.textContent=humanSpeed(bps); lastTime=now; lastUploaded=uploadedBytes+current; }
      };
      const form=new FormData();
      form.append('uploadId', uploadId);
      form.append('index', String(i));
      form.append('total', String(total));
      form.append('fileName', file.name);
      form.append('chunk', blob, chunking ? \`\${file.name}.part\${i}\` : file.name);
      xhr.send(form);
    });
  }

  entry.statusEl.textContent = 'åˆå¹¶ç™»è®°...';
  const completeResp = await fetch('/upload/complete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ uploadId, total })});
  const done = await completeResp.json().catch(()=> ({}));
  if(!completeResp.ok || !done.downloadUrl){ entry.statusEl.textContent='å¤±è´¥'; entry.uploading=false; throw new Error('å®Œæˆå¤±è´¥'); }

  // ç´¯è®¡å±•ç¤ºé“¾æ¥ï¼Œä¸æ¸…ç©ºåŸæ–‡ä»¶
  links.classList.remove('hidden');
  const line = document.createElement('div');
  line.innerHTML = \`<div class="mt-2">ä¸‹è½½ï¼š<a class="text-indigo-400 underline" href="\${done.downloadUrl}" target="_blank" rel="noopener">\${done.downloadUrl}</a></div>
                     <div>é¢„è§ˆï¼š<a class="text-indigo-400 underline" href="\${done.previewUrl}" target="_blank" rel="noopener">\${done.previewUrl}</a></div>\`;
  links.appendChild(line);

  entry.done = true;
  entry.uploading = false;
  entry.statusEl.textContent = 'å®Œæˆ';
  entry.speedEl.textContent = '';
}

function humanSpeed(bps){
  const units=['B/s','KB/s','MB/s','GB/s']; let i=0;
  while(bps>=1024 && i<units.length-1){ bps/=1024; i++; }
  return bps.toFixed(1)+' '+units[i];
}

function limitConcurrency(tasks, limit=3){
  let i=0, running=0;
  return new Promise((resolve)=>{
    const next=()=>{
      if(i>=tasks.length && running===0) return resolve();
      while(running<limit && i<tasks.length){
        const cur=i++; running++;
        tasks[cur]().finally(()=>{ running--; next(); });
      }
    };
    next();
  });
}

form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  if(ub.dataset.running==='1') return;
  const pending = selected.filter(x=>!x.done && !x.uploading);
  if(!pending.length) return;
  ub.dataset.running='1'; ub.disabled = true;

  const tasks = pending.map(entry=>()=>uploadOne(entry));
  await limitConcurrency(tasks, 3);

  ub.dataset.running='0';
  ub.disabled = selected.filter(x=>!x.done).length===0;
});

window.addEventListener('load', load);
</script>
</body>
</html>`;
}

// ---- SVG å›¾æ ‡ ----
function svgGithub() {
  return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#e5e7eb" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 .5A11.5 11.5 0 0 0 .5 12.4c0 5.26 3.41 9.72 8.15 11.3.6.11.82-.27.82-.6l-.01-2.1c-3.32.74-4.02-1.6-4.02-1.6-.55-1.43-1.35-1.8-1.35-1.8-1.1-.78.08-.76.08-.76 1.22.09 1.86 1.29 1.86 1.29 1.08 1.86 2.83 1.32 3.52 1.01.11-.8.42-1.33.77-1.63-2.65-.31-5.44-1.36-5.44-6.07 0-1.34.47-2.43 1.25-3.29-.13-.31-.54-1.56.12-3.26 0 0 1.01-.33 3.3 1.26.96-.27 1.99-.41 3.01-.42 1.02.01 2.05.15 3.01.42 2.29-1.59 3.3-1.26 3.3-1.26.66 1.7.25 2.95.12 3.26.78.86 1.25 1.95 1.25 3.29 0 4.72-2.8 5.75-5.47 6.06.43.37.82 1.1.82 2.22l-.01 3.29c0 .33.22.72.83.6A11.51 11.51 0 0 0 23.5 12.4 11.5 11.5 0 0 0 12 .5z"/></svg>`;
}
function svgLink() {
  return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="#e5e7eb" viewBox="0 0 24 24" aria-hidden="true"><path d="M3.9 12a5 5 0 0 1 5-5h3v2h-3a3 3 0 0 0 0 6h3v2h-3a5 5 0 0 1-5-5Zm7-1h3a3 3 0 0 1 0 6h-3v-2h3a1 1 0 1 0 0-2h-3v-2Zm0-2V7h3a5 5 0 0 1 0 10h-3v-2"/></svg>`;
}
```
